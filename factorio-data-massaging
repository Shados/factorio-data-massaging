#!/usr/bin/env -S yue -e
import "argparse"
import "inspect"
import "jsonschema"
import "unix"
import "rapidjson"
import "serpent"
import "ssl.https"
import "lib" as :deep_copy, :lsdir, :run_cmd, :split_string, :xdg_home_default

local *

API_BASE = "https://lua-api.factorio.com"
SCRIPT_DIR = do
  str = debug.getinfo(1, "S").source
  str\match "(.*)/"
CACHE_DIR = "#{xdg_home_default "cache"}/factorio-data-generation"
FACTORIO_DATA_DIR = "#{CACHE_DIR}/factorio-data"
FACTORIO_DATA_REPO_DIR = "#{CACHE_DIR}/factorio-data-repo"
JSON_DOCS_DIR = "#{SCRIPT_DIR}/json-docs"
LUA_DATA_DIR = "#{SCRIPT_DIR}/lua-data"
RUNTIME_DOCS_DIR = "#{JSON_DOCS_DIR}/runtime-api"
RUNTIME_DOCS_EARLIEST_VERSION = {1, 1, 35}
FIRST_VERSION_WITHOUT_MODULE = { 2, 0, 0 }
PROTOTYPE_DOCS_DIR = "#{JSON_DOCS_DIR}/prototype-api"
PROTOTYPE_DOCS_EARLIEST_VERSION = {1, 1, 89}
SCHEMA_DIR = "#{SCRIPT_DIR}/schemas"
KNOWN_BUGGED_RUNTIME_DOC_VERSIONS = {
  "1.1.108": true
}
KNOWN_BUGGED_PROTOTYPE_DOC_VERSIONS = {
}
INSTRUMENT_MODE_REMOVED_LUA_GLOBALS = {
  "coroutine"
  "dofile"
  "io"
  "loadfile"
  "os"
  -- Everything but package.loaded
  "package.config"
  "package.cpath"
  "package.loadlib"
  "package.path"
  "package.preload"
  "package.searchers"
  "package.searchpath"
}
REMOVED_LUA_GLOBALS = {
  ...INSTRUMENT_MODE_REMOVED_LUA_GLOBALS
  -- Only getinfo() and traceback() left in debug by default
  "debug.debug"
  "debug.gethook"
  "debug.getlocal"
  "debug.getmetatable"
  "debug.getregistry"
  "debug.getupvalue"
  "debug.getuservalue"
  "debug.sethook"
  "debug.setlocal"
  "debug.setmetatable"
  "debug.setupvalue"
  "debug.setuservalue"
  "debug.upvalueid"
  "debug.upvaluejoin"
}
-- Some of the core mod's lualibs don't properly require() one another, we
-- document the missing entries here so we can properly lift values from them
-- in lift_core_lualib().
CORE_MOD_LUALIB_MISSED_REQUIRES = {
  "circuit-connector-sprites": { "util" }
}
-- Some of the core mod's lualibs aren't meant to be directly require()'d from
-- the outside, but only internally by other lualibs or toolling.
CORE_MOD_LUALIB_CANNOT_REQUIRE = {
  "circuit-connector-generated-definitions": true
  "builder": true
}
-- Don't know why these aren't mentioned in the API doc JSON files; they *could* be
ADDED_LUA_GLOBALS = {
  "storage" -- nee `global`
  "serpent._COPYRIGHT"
  "serpent._DESCRIPTION"
  "serpent._NAME"
  "serpent._VERSION"
  "serpent.block"
  "serpent.dump"
  "serpent.line"
  "serpent.load"
  "serpent.serialize"
  "string.pack"
  "string.packsize"
  "string.unpack"
  -- Undocumented, appears to be a `pairs`-iterating version of `table.concat`,
  -- but implemented on the C/++ side?
  "table.pairs_concat"
  -- Things deprecated in Lua 5.2 but still present -- TODO confirm these aren't in luacheck's 5.2 std?
  "loadstring" -- Here it is just an alias for load
  "table.maxn"
  "unpack" -- Alias for table.unpack
}
INSTRUMENT_MODE_LUA_GLOBALS = {
  "on_error"
}
PROTOTYPE_LUA_GLOBALS = {
  "data"
  "data.raw"
  "data.extend"
  "data.is_demo"
  "mods"
  "settings.startup"
  -- Exists
  "feature_flags"
}
PROTOTYPE_LOADED_LUALIBS = {
  "util"
  "bonus-gui-ordering"
  "sound-util"
}


main = ->
  doc_version_list = get_doc_versions!
  most_recent_version = doc_version_list[#doc_version_list].version
  ensure_docs doc_version_list

  parser = argparse!
  with parser
    \name "factorio-data-generation"
    \description "A tool for generating useful data and configuration from Factorio (meta)data files"
    \command "latest-version"
    \command "luacheckrc"
    \command "extract-core-lualibs"
    \command "validate"
    \command_target "command"
    \require_command false

  args = parser\parse arg
  print "args: #{inspect args}"

  switch args.command
    when "extract-core-lualibs"
      ensure_factorio_data!
      for {:version} in *doc_version_list
        extract_core_lualibs version
    when "latest-version"
      print most_recent_version
    when "luacheckrc"
      generate_luacheckrc_files doc_version_list
    when "validate"
      validate_json_docs doc_version_list

  return


debug_print = (...) ->
  (os.getenv "DEBUG") and print(...)


get_doc_versions = ->
  unix.mkpath CACHE_DIR
  cached_file = "#{CACHE_DIR}/api-docs-version-list.html"
  ensure_url_downloaded API_BASE, cached_file
  with io.open cached_file, "r"
    html_str = \read "*a"
    \close!
    return parse_versions_html html_str


parse_versions_html = (html_str) ->
  -- Aww yeah, time to ~~parse~~scrape HTML with regex :V
  versions = [{(tonumber major), (tonumber minor), (tonumber sub)} for major, minor, sub in html_str\gmatch ">%s-(%d+)%.(%d+)%.(%d+)%s-<"]
  table.sort versions, version_sort
  versions = for version in *versions
    continue unless  version_at_least RUNTIME_DOCS_EARLIEST_VERSION, version
    {:version, has_prototype_docs: version_at_least PROTOTYPE_DOCS_EARLIEST_VERSION, version}
  return [{version: "#{v[1]}.#{v[2]}.#{v[3]}", :has_prototype_docs} for {version: v, :has_prototype_docs} in *versions]


version_at_least = (compare_to, version) ->
  if compare_to[1] != version[1]
    return compare_to[1] <= version[1]
  if compare_to[2] != version[2]
    return compare_to[2] <= version[2]
  if compare_to[3] != version[3]
    return compare_to[3] <= version[3]
  return true


version_sort = (a, b) ->
  if a[1] != b[1]
    return a[1] < b[1]
  if a[2] != b[2]
    return a[2] < b[2]
  else
    return a[3] < b[3]


ensure_docs = (doc_version_list) ->
  unix.mkpath RUNTIME_DOCS_DIR
  unix.mkpath PROTOTYPE_DOCS_DIR
  for {:version, :has_prototype_docs} in *doc_version_list
    cached_runtime_file = "#{RUNTIME_DOCS_DIR}/#{version}.json"
    ensure_url_downloaded "#{API_BASE}/#{version}/runtime-api.json", cached_runtime_file
    if has_prototype_docs
      cached_prototype_file = "#{PROTOTYPE_DOCS_DIR}/#{version}.json"
      ensure_url_downloaded "#{API_BASE}/#{version}/prototype-api.json", cached_prototype_file

  return


ensure_factorio_data = () ->
  unless unix.stat FACTORIO_DATA_REPO_DIR
    cmd = "git clone --bare https://github.com/wube/factorio-data #{FACTORIO_DATA_REPO_DIR}"
    print "Fetching factorio-data repo: #{cmd}"
    run_cmd cmd
  else
    cmd = "git -C #{FACTORIO_DATA_REPO_DIR} fetch --all"
    print "Updating factorio-data repo: #{cmd}"
    run_cmd cmd

  cmd = "git -C #{FACTORIO_DATA_REPO_DIR} --no-pager tag --list"
  tag_fd = io.popen cmd, "r"
  versions = tag_fd\read "*a"
  versions = split_string versions, "\n"
  table.remove versions -- Remove trailing newline

  for version in *versions
    version_dir = "#{FACTORIO_DATA_DIR}/#{version}"
    continue if unix.stat version_dir
    unix.mkpath version_dir
    print "Checking out factorio-data for version #{version}"
    cmd = "git -C #{FACTORIO_DATA_REPO_DIR} archive #{version} | tar -x -C #{version_dir}"
    run_cmd cmd
  return


extract_core_lualibs = (version) ->
  data_dir = "#{FACTORIO_DATA_DIR}/#{version}"
  unless unix.stat data_dir
    print "#{version}: No factorio-data directory available for this version"
    return

  lualib_path = "#{data_dir}/core/lualib"
  lib_dir_files = lsdir lualib_path

  early_lib_set = {lib, false for lib in *PROTOTYPE_LOADED_LUALIBS}
  libraries = {}
  for child_path in *lib_dir_files
    libname = child_path\match "^(.+)%.lua$"
    continue unless libname
    -- These libs are loaded in the data phase by the core mod, get special handling >.>
    if early_lib_set[libname] != nil
      -- Track which early libs are present in this version
      early_lib_set[libname] = true
      continue
    libraries[]= libname
  table.sort libraries

  runtime_api_json = rapidjson.load "#{RUNTIME_DOCS_DIR}/#{version}.json"
  lua_data_dir = "#{LUA_DATA_DIR}/#{version}"
  unix.mkpath lua_data_dir

  early_new_globals = {}
  -- Gotta handle these first, as we need their global lists to exclude from others.
  -- This is because it's actually loaded by core mod's data stage, which is
  -- what we're using as the baseline to judge the other libs...
  early_libs = [lib for lib, present in pairs early_lib_set when present]
  for i, lib in ipairs early_libs
    table.insert libraries, i, lib
  for library in *libraries
    if CORE_MOD_LUALIB_CANNOT_REQUIRE[library]
      continue
    cached_file = "#{lua_data_dir}/#{library}.json"
    if unix.stat cached_file
      debug_print "#{version}: Already lifted library '#{library}'"
      continue
    print "#{version}: Lifting liibrary '#{library}'"

    sandbox_env = setup_sandbox_env runtime_api_json, data_dir

    baseline_global_env = if early_lib_set[library]
      -- Load the early lib without loading data stage, compare against no-data baseline
      deep_copy(sandbox_env)
    else
      data_stage_code_str = [[
      require("data.lua") -- Run the data stage for the core mod, ish
      return _G
      ]]

      sandbox_run, err = load data_stage_code_str, "factorio-data-generation.sandbox", "t", sandbox_env
      assert sandbox_run, err

      deep_copy(sandbox_run!)

    code_str = sandboxed_lualib_code_str library

    sandbox_run, err = load code_str, "factorio-data-generation.sandbox", "t", sandbox_env
    assert sandbox_run, err
    modified_global_env, loaded_module = sandbox_run!

    -- Strip recursive values & the data segment before comparing
    baseline_global_env._G = nil
    baseline_global_env.package.loaded = nil
    baseline_global_env.data = nil
    modified_global_env._G = nil
    modified_global_env.package.loaded = nil
    modified_global_env.data = nil

    new_globals = diff_table_paths baseline_global_env, modified_global_env

    table.sort new_globals
    if early_lib_set[library]
      for g in *new_globals
        early_new_globals[g] = true
    else
      new_globals = [g for g in *new_globals when early_new_globals[g] == nil]
    loaded_module_names = if loaded_module
      library_module_name = library\gsub "-", "_"
      extract_table_namespace loaded_module, "#{library_module_name}."
    else
      nil
    if loaded_module_names
      table.sort loaded_module_names

    -- Options here are to ensure multi-line, stably-sorted JSON files so they're more git-friendly
    rapidjson.dump {:new_globals, :loaded_module_names, :library}, cached_file, { pretty: true, sort: true }
  return

LIFT_CORE_LUALIB_FORMAT_STR = [[
local mod = require("%s")
return _G, mod
]]
sandboxed_lualib_code_str = (lualib) ->
  if extra_requires := CORE_MOD_LUALIB_MISSED_REQUIRES[lualib]
    str = ""
    for req in *extra_requires
      str ..= "local #{req} = require(\"#{req}\")\n"
    str ..= string.format LIFT_CORE_LUALIB_FORMAT_STR, lualib
    return str
  else
    return string.format LIFT_CORE_LUALIB_FORMAT_STR, lualib

diff_table_paths = (baseline, other, prefix="") ->
  new_globals = {}
  for k, v in pairs other
    -- Don't care about array values, skip 'em
    continue if (type k) == "number"
    if (type v) == "table"
      -- Recurse to handle table children
      children = if baseline
        diff_table_paths baseline[k], v, "#{prefix}#{k}."
      else
        diff_table_paths nil, v, "#{prefix}#{k}."
      for child in *children
        new_globals[]= child
    if baseline == nil or baseline[k] == nil
      new_globals[]= "#{prefix}#{k}"
  return new_globals

extract_table_namespace = (t, prefix="") ->
  names = {}
  for k, v in pairs t
    -- Don't care about array values, skip 'em
    continue if (type k) == "number"
    names[] = "#{prefix}#{k}"
    if (type v) == "table"
      -- Recurse to handle table children
      for child in *(extract_table_namespace v, "#{prefix}#{k}.")
        names[] = child
  return names

-- Prepare a sandboxed environment similar to Factorio's own
setup_sandbox_env = (runtime_api_json, data_dir) ->
  stage_globals = build_runtime_globals runtime_api_json
  sandbox_env = {
    ...stage_globals
    -- :_G
    :_VERSION
    :arg
    :assert
    :bit32
    :collectgarbage
    -- :coroutine
    -- :debug
    -- :dofile
    :error
    :getmetatable
    -- :io
    :ipairs
    -- :load
    -- :loadfile
    :math
    :next
    -- :os
    -- :package
    :pairs
    :pcall
    :print
    :rawequal
    :rawget
    :rawlen
    :rawset
    -- :require
    :select
    :setmetatable
    -- :string
    -- :table
    :tonumber
    :tostring
    :type
    :xpcall
  }
  sandbox_env._G = sandbox_env
  -- Not a runtime stage global, but a data stage global that is used by some
  -- of the lualibs for some versions.
  sandbox_env.data = {
    extend: (self, otherdata) ->
      if type(otherdata) ~= "table" or #otherdata == 0
        error("Invalid prototype array " .. serpent.block(otherdata, {maxlevel: 1}))

      for e in *otherdata
        unless e.type
          error("Missing type in the following prototype definition " .. serpent.block(e))
        unless e.name
          error("Missing name in the following prototype definition " .. serpent.block(e))

        t = self.raw[e.type]
        if t == nil
          t = {}
          self.raw[e.type] = t
        t[e.name] = e
    raw: {}
    is_demo: false
  }
  sandbox_env.debug = { getinfo: debug.getinfo, traceback: debug.traceback }
  sandbox_env.load = (ld, source, _, env=sandbox_env) ->
    load ld, source, "t", env

  sandbox_env.loadstring = sandbox_env.load
  sandbox_env.serpent = require "serpent"
  sandbox_env.storage = {}
  sandbox_env.string = {k, v for k,v in pairs string}
  compat53 = require "compat53.module"
  sandbox_env.string.pack = compat53.string.pack
  sandbox_env.string.packsize = compat53.string.packsize
  sandbox_env.string.unpack = compat53.string.unpack
  sandbox_env.table = {k, v for k,v in pairs table}
  isinteger = (n) ->
    assert type n == "number", "isinteger only takes numerical values as input, not: #{n}"
    {_, fractional} = math.modf n
    return fractional == 0
  sandbox_env.table.maxn = (t) ->
    math.max table.unpack [k for k, _ in pairs t when type k == "number" and isinteger k]
  sandbox_env.table.pairs_concat = (t) -> table.concat [v for _, v in pairs t]
  sandbox_env.unpack = table.unpack

  -- Rewrite require()
  sandbox_env.package = { loaded: {} }
  sandbox_env.require = (path) ->
    if sandbox_env.package.loaded[path]
      return sandbox_env.package.loaded[path]

    current_mod = 'core'
    search_path = { "#{data_dir}/core/lualib" } -- Core's lualib is always in the search path
    assert (path\match "%.%.") == nil, "Cannot use '..' in require() paths"
    sub_path = if (path\sub 1, 2) == '__'
      -- Load from other mod root
      other_mod, sub_path = path\match "^__(.-)__%.(.+)$"
      assert other_mod != nil, "Invalid mod-reference path in require: #{path}"
      search_path[]= "#{data_dir}/#{other_mod}"
      sub_path
    else
      -- Load relative to mod root
      search_path[]= "#{data_dir}/#{current_mod}"
      path

    if (sub_path\sub -4) == ".lua"
      sub_path = sub_path\sub 1, sub_path\len! - 4

    sub_path = sub_path\gsub "%.", "/"
    for dir_path in *search_path
      file_path = "#{dir_path}/#{sub_path}.lua"
      if unix.stat file_path
        fd, err = io.open file_path, "r"
        assert fd != nil, "error loading module `#{path}' (#{err})"
        file_str = fd\read "*a"
        fd\close!
        func, err = sandbox_env.load file_str, path
        assert func != nil, "error loading module `#{path}' (#{err})"
        mod = func!
        sandbox_env.package.loaded[path] = mod
        return mod

    error "module `#{path}' not found: ", 2

  return sandbox_env


-- Stub just enough of the runtime global variables and functions that we can
-- load Factorio's lualibs
build_runtime_globals = (runtime_api_json) ->
  defines = build_lua_defines runtime_api_json.defines
  globals = { :defines }

  if runtime_api_json.global_functions
    for {:name} in *runtime_api_json.global_functions
      switch name
        when "localised_print"
          globals.localised_print = (...) -> print (inspect ...)
        when "log"
          globals.log = (...) -> print ...
        when "table_size"
          globals.table_size = (t) ->
            count = 0
            for _, _ in pairs t
              count += 1
            count
        else
          error "Have not written an implementation for global_function #{name}"

  classes = {}
  for klass_attr in *runtime_api_json.classes
    {:name, :methods, :attributes, :operators} = klass_attr
    klass = {}
    for method in *methods
      klass[method.name] = -> nil
    for attribute in *attributes
      klass[attribute.name] = {}
    mt = {}
    has_ops = false
    for operator in *operators
      switch operator.name
        when "call"
          has_ops = true
          mt.__call = -> nil
        when "index"
          has_ops = true
          mt.__index = -> nil
        when "length"
          has_ops = true
          mt.__len = -> nil
        else
          error "Have not written an implementation for operator #{operator.name}"
    if has_ops
      setmetatable klass, mt
    classes[name] = klass

  for obj in *runtime_api_json.global_objects
    globals[obj.name] = classes[obj.type]

  return globals

build_lua_defines = (defines_json) ->
  lua_defines = {}
  for { :name, :values, :subkeys } in *defines_json
    if values
      lua_define = {}
      lua_defines[name] = lua_define
      -- Enum-like, assign arbitrary incrementing values
      i = 0
      for value in *values
        i += 1
        lua_define[value.name] = i
    else if subkeys
      -- Tree-like, recurse
      sub_defines = build_lua_defines subkeys
      lua_defines[name] = sub_defines
    else
      debug_print "value-less define: #{name}"
      lua_defines[name] = 1
  return lua_defines

build_prototype_globals = () ->
  -- TODO?
  error "unimplemented"


generate_luacheckrc_files = (versions) ->
  version = versions[#versions].version
  runtime_api_json = rapidjson.load "#{RUNTIME_DOCS_DIR}/#{version}.json"
  prototype_api_json = rapidjson.load "#{PROTOTYPE_DOCS_DIR}/#{version}.json"
  -- lualib_json = {}
  -- children = lsdir lualib_dir
  -- for child in *children
  --   lualib_json[child] = rapidjson.load "#{lualib_dir}/#{child}"

  lualib_dir = "#{LUA_DATA_DIR}/#{version}"
  lualib_data_stage_globals = {}
  -- Include core-mod's `util`, `bonus-gui-ordering`, and `sound-util`
  -- libraries as part of the accessible globals during the prototype stage, as
  -- these are loaded by the core-mod at that point, and the prototype stage
  -- uses a single shared Lua state for all mods.
  for lib in *PROTOTYPE_LOADED_LUALIBS
    lualib_json = rapidjson.load "#{lualib_dir}/#{lib}.json"
    for path in *lualib_json.new_globals
      lualib_data_stage_globals[path] = true
  lualib_data_stage_globals = [k for k, _ in pairs lualib_data_stage_globals]

  data_stage_defines = extract_defines_namespace prototype_api_json.defines, "defines."

  -- Populate the feature_flags mapping, if present TODO replace with pattern match on runtime flags instead?
  feature_flags = {}
  for {:name, :attributes} in *runtime_api_json.classes
    continue if name != "LuaBootstrap"
    for attribute in *attributes
      continue if attribute.name != "feature_flags"
      flag_names = ["feature_flags.#{name}" for {:name} in *attribute.read_type.parameters]
      feature_flags = flag_names

  data_stage_globals = {
    "data.raw"
    "data.extend"
    "data.is_demo"
  }

  data_stage_new_globals = {
    ...feature_flags
    ...data_stage_defines
    ...data_stage_globals
    ...lualib_data_stage_globals
  }

  table.sort data_stage_new_globals
  print serpent.block data_stage_new_globals

  -- Get set of globals added by Factorio
  -- TODO set luacheck base std option to lua 5.2
  error("unimplemented")


extract_defines_namespace = (defines_json, prefix="") ->
  names = {}
  for {:name, :values, :subkeys} in *defines_json
    if values
      -- Enum-like
      for value in *values
        names[] = "#{prefix}#{name}.#{value.name}"
    else if subkeys
      -- Tree-like
      for child in *(extract_defines_namespace subkeys, "#{prefix}#{name}.")
        names[] = child
    else
      names[] = "#{prefix}#{name}"
  return names


validate_json_docs = (versions) ->
  runtime_validators, prototype_validators = initialise_json_schema_validators!
  print "Validating machine-readable runtime API docs against JSON Schemas"
  for {:version} in *versions
    runtime_api_json = rapidjson.load "#{RUNTIME_DOCS_DIR}/#{version}.json"
    runtime_validator = runtime_validators[runtime_api_json.api_version]
    if runtime_validator
      valid, err = runtime_validator runtime_api_json
      if valid
        print "runtime #{version}: valid"
      else
        if KNOWN_BUGGED_RUNTIME_DOC_VERSIONS[version]
          print "runtime #{version}: invalid: known issue, the JSON from this version is bugged, see #{SCHEMA_DIR}/runtime-api-docs-bugs.md"
        else
          print "runtime #{version}: invalid"
        print err

  for {:version, :has_prototype_docs} in *versions
    continue unless has_prototype_docs
    prototype_api_json = rapidjson.load "#{PROTOTYPE_DOCS_DIR}/#{version}.json"
    prototype_validator = prototype_validators[prototype_api_json.api_version]
    if prototype_validator
      valid, err = prototype_validator prototype_api_json
      if valid
        print "prototype #{version}: valid"
      else
        if KNOWN_BUGGED_PROTOTYPE_DOC_VERSIONS[version]
          print "prototype #{version}: invalid: known issue, the JSON from this version is bugged, see #{SCHEMA_DIR}/prototype-api-docs-bugs.md"
        else
          print "prototype #{version}: invalid"
        print err


initialise_json_schema_validators = ->
  print "Parsing JSON Schemas"
  schema_files = lsdir SCHEMA_DIR
  runtime_validators = {}
  prototype_validators = {}
  for name in *schema_files
    version = name\match "^runtime%-api%-docs%-v(%d+)%.json$"
    if version
      schema_json = rapidjson.load "#{SCHEMA_DIR}/#{name}"
      runtime_validators[tonumber version] = jsonschema.generate_validator schema_json, { null: rapidjson.null }
    else
      version = name\match "^prototype%-api%-docs%-v(%d+)%.json$"
      continue unless version
      schema_json = rapidjson.load "#{SCHEMA_DIR}/#{name}"
      prototype_validators[tonumber version] = jsonschema.generate_validator schema_json, { null: rapidjson.null }

  return runtime_validators, prototype_validators


ensure_url_downloaded = (url, path) ->
  if unix.stat path
    debug_print "Already have file downloaded at #{path}"
  else
    print "Fetching url #{url}"
    res, code, _, status = https.request url
    assert res, "Failed to fetch url (#{url}), code: #{code}, status: #{status}"
    with io.open path, "w"
      \write res
      \close!


main!
return
