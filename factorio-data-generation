#!/usr/bin/env -S yue -e

import "argparse"
import "inspect"
import "jsonschema"
import "unix"
import "rapidjson"
import "ssl.https"

local *

API_BASE = "https://lua-api.factorio.com"
SCRIPT_DIR = do
  str = debug.getinfo(1, "S").source
  str\match "(.*)/"
CACHE_DIR = "#{SCRIPT_DIR}/cache"
JSON_DOCS_DIR = "#{SCRIPT_DIR}/json-docs"
RUNTIME_DOCS_DIR = "#{JSON_DOCS_DIR}/runtime-api"
RUNTIME_DOCS_EARLIEST_VERSION = {1, 1, 35}
PROTOTYPE_DOCS_DIR = "#{JSON_DOCS_DIR}/prototype-api"
PROTOTYPE_DOCS_EARLIEST_VERSION = {1, 1, 89}
SCHEMA_DIR = "#{SCRIPT_DIR}/schemas"
KNOWN_BUGGED_RUNTIME_DOC_VERSIONS = {
  "1.1.108": true
}
KNOWN_BUGGED_PROTOTYPE_DOC_VERSIONS = {
}


main = ->
  doc_version_list = get_doc_versions!
  most_recent_version = doc_version_list[#doc_version_list]
  ensure_docs doc_version_list

  parser = argparse!
  with parser
    \name "factorio-data-generation"
    \description "A tool for generating useful data and configuration from Factorio (meta)data files"
    \command "validate"
    \command_target "command"
    \require_command false

  args = parser\parse arg
  print "args: #{inspect args}"

  switch args.command
    when nil
      print "no command"
    when "validate"
      validate_json_docs doc_version_list

  return

debug_print = (...) ->
  (os.getenv "DEBUG") and print(...)

get_doc_versions = ->
  unix.mkpath CACHE_DIR
  cached_file = "#{CACHE_DIR}/api-docs-version-list.html"
  ensure_url_downloaded API_BASE, cached_file
  with io.open cached_file, "r"
    html_str = \read "*a"
    \close!
    return parse_versions_html html_str

parse_versions_html = (html_str) ->
  versions = [{(tonumber major), (tonumber minor), (tonumber sub)} for major, minor, sub in html_str\gmatch ">%s-(%d+)%.(%d+)%.(%d+)%s-<"]
  table.sort versions, version_sort
  versions = for version in *versions
    continue unless  version_at_least RUNTIME_DOCS_EARLIEST_VERSION, version
    {:version, has_prototype_docs: version_at_least PROTOTYPE_DOCS_EARLIEST_VERSION, version}
  return [{version: "#{v[1]}.#{v[2]}.#{v[3]}", :has_prototype_docs} for {version: v, :has_prototype_docs} in *versions]

version_at_least = (compare_to, version) ->
  if compare_to[1] != version[1]
    return compare_to[1] <= version[1]
  if compare_to[2] != version[2]
    return compare_to[2] <= version[2]
  if compare_to[3] != version[3]
    return compare_to[3] <= version[3]
  return true

version_sort = (a, b) ->
  if a[1] != b[1]
    return a[1] < b[1]
  if a[2] != b[2]
    return a[2] < b[2]
  else
    return a[3] < b[3]

ensure_docs = (doc_version_list) ->
  unix.mkpath RUNTIME_DOCS_DIR
  unix.mkpath PROTOTYPE_DOCS_DIR
  for {:version, :has_prototype_docs} in *doc_version_list
    cached_runtime_file = "#{RUNTIME_DOCS_DIR}/#{version}.json"
    ensure_url_downloaded "#{API_BASE}/#{version}/runtime-api.json", cached_runtime_file
    if has_prototype_docs
      cached_prototype_file = "#{PROTOTYPE_DOCS_DIR}/#{version}.json"
      ensure_url_downloaded "#{API_BASE}/#{version}/prototype-api.json", cached_prototype_file

  return

validate_json_docs = (versions) ->
  runtime_validators, prototype_validators = initialise_json_schema_validators!
  print "Validating machine-readable runtime API docs against JSON Schemas"
  for {:version} in *versions
    runtime_api_json = rapidjson.load "#{RUNTIME_DOCS_DIR}/#{version}.json"
    runtime_validator = runtime_validators[runtime_api_json.api_version]
    if runtime_validator
      valid, err = runtime_validator runtime_api_json
      if valid
        print "runtime #{version}: valid"
      else
        if KNOWN_BUGGED_RUNTIME_DOC_VERSIONS[version]
          print "runtime #{version}: invalid: known issue, the JSON from this version is bugged, see #{SCHEMA_DIR}/runtime-api-docs-bugs.md"
        else
          print "runtime #{version}: invalid"
        print err

  for {:version, :has_prototype_docs} in *versions
    continue unless has_prototype_docs
    prototype_api_json = rapidjson.load "#{PROTOTYPE_DOCS_DIR}/#{version}.json"
    prototype_validator = prototype_validators[prototype_api_json.api_version]
    if prototype_validator
      valid, err = prototype_validator prototype_api_json
      if valid
        print "prototype #{version}: valid"
      else
        if KNOWN_BUGGED_PROTOTYPE_DOC_VERSIONS[version]
          print "prototype #{version}: invalid: known issue, the JSON from this version is bugged, see #{SCHEMA_DIR}/prototype-api-docs-bugs.md"
        else
          print "prototype #{version}: invalid"
        print err

initialise_json_schema_validators = ->
  print "Parsing JSON Schemas"
  schema_dir, err, errno = unix.opendir SCHEMA_DIR
  assert schema_dir != nil, "Failed to open #{SCHEMA_DIR}, errno #{errno}, error: #{err}"
  runtime_validators = {}
  prototype_validators = {}
  for {:name} in schema_dir\files!
    version = name\match "^runtime%-api%-docs%-v(%d+)%.json$"
    if version
      schema_json = rapidjson.load "#{SCHEMA_DIR}/#{name}"
      runtime_validators[tonumber version] = jsonschema.generate_validator schema_json, { null: rapidjson.null }
    else
      version = name\match "^prototype%-api%-docs%-v(%d+)%.json$"
      continue unless version
      schema_json = rapidjson.load "#{SCHEMA_DIR}/#{name}"
      prototype_validators[tonumber version] = jsonschema.generate_validator schema_json, { null: rapidjson.null }


  return runtime_validators, prototype_validators

ensure_url_downloaded = (url, path) ->
  if unix.stat path
    debug_print "Already have file downloaded at #{path}"
  else
    print "Fetching url #{url}"
    res, code, _, status = https.request url
    assert res, "Failed to fetch url (#{url}), code: #{code}, status: #{status}"
    with io.open path, "w"
      \write res
      \close!

main!
return
